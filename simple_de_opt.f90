!==Class simple_de_opt
!
! simple_de_opt performs constrained minimization of an externally defined function by advanced differential evolution optimization
! equipped with a ring-topological neighborhood structure for balancing between intensification and diversification of the search.
! The code is distributed with the hope that it will be useful, but _WITHOUT_ _ANY_ _WARRANTY_. Redistribution or modification is 
! regulated by the GNU General Public License. 
! *Author:* Hans Elmlund, 2009-05-25.
!
!=Usage
! (1) make the object for optimization by the constructor
! In the newly created object, the solution vector population is intialized randomly uniformly over the parameters.
! This is not the best strategy for initialization. If a feasible solution can be generated by some other heuristics
! it can be used for initialization by the re_init_de_opt method. For example, in the single-particle refinement I am 
! using exhaustive angular search in a discrete space and origin shift randomization for initialization of the optimizer.
! (2) apply re-initialization if needed
! (3) optimize using de_cont_min
! The object can be re-used with the re-initialization procedure, which also enables unsupervised learning of refinement parameters
! For further information, see (REF)
!==Changes are documented below
!
!* restructured, HE 2009-05-26
!* deugged and incorporated in the _SIMPLE_ library, HE 2009-06-25
!* randomized the ring search, HE 2011-01-01
!* introduced read/write pop routines for re-loading in refinement, HE 2011-03-01
!
module simple_de_opt
use simple_rnd
use simple_ran_tabu
use simple_math
use simple_jiffys
implicit none

private :: ind, calc_cost, sel, m_and_x_glob, m_and_x_loc, find_best_glob, find_best_loc, check_vec
public

type :: ind
! is the individual containing, vector length, vector cost, self-adaptive
! amplification factor, vector values, best vec in neigh and its cost  
    real              :: cost=0. ! vector cost
    real              :: F=0. ! amplification factor
    real              :: w=0. ! weight factor
    real, allocatable :: vec(:) ! vector values
    integer           :: best_loc=0 ! best vec in neigh
    real              :: best_loc_cost=0. ! cost of best vec in neigh
end type ind

type de_opt
! contains all that is needed for the DE search
    private
    type(ind), allocatable :: pop(:) ! solution vector population
    type(ind)              :: trial, trial_loc, trial_glob ! trial vecs
    type(ran_tabu)         :: tab ! for random number generation
    real, allocatable      :: limits(:,:) ! optimization constraints
    logical, allocatable   :: cyclic(:) ! to indicate which variables are cyclic
    integer                :: NP=0 ! population size
    integer                :: D=0 ! vector lengt
    integer                :: neigh=0 ! neighbourhood size (-neigh:neigh)
    integer                :: best_glob=0 ! globally best vec
    real                   :: best_glob_cost=0. ! cost of globally best vec
    logical                :: exists
end type de_opt

contains

    function new_de_opt( L, limits, NP, neigh, cyclic, init_sols ) result( num )
    ! constructs the population. L is the problem dimension, limits is the array describing the variable bounds,
    ! NP is the size of the population, which should be ~10*(L+1), neigh is the neighborhood size, which needs to be 
    ! empirially determined for each problem, cyclic is a logical array indicating if a variable should be considered
    ! as cyclic or not (useful for Euler angles), _init_sols_ enables external definition of initial solutions, which
    ! is useful for refining a solution in a given neighbourhood.
        type(de_opt)                  :: num
        integer, intent(in)           :: L ! vector dimension
        real, intent(in)              :: limits(L,2) ! constraints
        integer, intent(in)           :: NP ! population size
        real, intent(in)              :: neigh ! neighborhood size as fraction of NP
        logical, intent(in), optional :: cyclic(L) ! to denote variables with cyclic limits
        real, intent(in),optional     :: init_sols(NP,L) ! solutions for initialization
        integer                       :: alloc_stat, i, j, order(NP), ir
        ! allocate the population array and the trial vector
        allocate( num%pop(NP), num%trial%vec(L), num%trial_loc%vec(L),&
        num%trial_glob%vec(L), num%limits(L,2), num%cyclic(L), stat = alloc_stat )
        call alloc_err( 'In: new_de_opt module: simple_de_opt.f90, alloc 1', alloc_stat )
        num%tab = new_ran_tabu(NP)
        num%D = L
        num%NP = NP
        num%limits = limits
        num%neigh = min((NP-1)/2,nint(neigh*real(NP)))
        num%cyclic = .false.
        if( present(cyclic) ) num%cyclic = cyclic  
        ! loop over individuals
        do i=1,NP
            num%trial%F = 0.1+0.9*ran3()
            num%pop(i)%w = ran3()
            allocate( num%pop(i)%vec(L), stat=alloc_stat )
            call alloc_err( 'In: new_de_opt module: simple_de_opt.f90, aloc 2', alloc_stat )
            ! loop over vector values
            do j=1,L
                ! determine interval size
                if(limits(j,2) > limits(j,1)) then
                else
                    write(*,*) 'Bad limits for the constrained optimization!'
                    write(*,*) 'In: new_de_opt module: simple_de_opt'
                    write(*,*) 'Lim(',j,1,'):',limits(j,1),'Lim(',j,2,'):',limits(j,2)
                    stop
                endif
                ! store the initial random values within the range in pop
                num%pop(i)%vec(j) = (limits(j,2)-limits(j,1))*ran3()+limits(j,1)
            end do
        end do
        if( present(init_sols) )then
            call reset_ran_tabu( num%tab )
            call ne_ran_iarr( num%tab, order )        
            do ir=1,NP ! loop over individuals
                i = order(ir) ! input individuals randomly ordered to promote neighbourhood diversity           
                do j=1,L ! loop over vector values
                    if( init_sols(i,j) < limits(j,1) .or.&
                        init_sols(i,j) > limits(j,2)) then
                        write( *,* ) 'Initial solution is out of bound!'
                        write( *,* ) 'In: new_de_opt module: simple_de_opt'
                        write( *,* ) 'Val:', init_sols(i,j), 'Lim(',j,1,'):',&
                        limits(j,1),'Lim(',j,2,'):',limits(j,2)
                    endif
                    ! store the init solutions in pop
                    num%pop(i)%vec(j) = init_sols(i,j)
                end do
                call check_vec( num, num%pop(i)%vec )
            end do
        endif
        num%exists = .true.
    end function new_de_opt
   
    subroutine re_init_de_opt( num, limits, init_sols )
    ! re-initializes an already existing optimization object, avoiding re-initialization of the scaling factors
        type(de_opt)               :: num
        real, intent(in)           :: limits(num%D,2) ! vector value limits
        real, intent(in), optional :: init_sols(num%NP,num%D)
        integer                    :: i, j, order(num%NP), ir
        if( num%exists )then
            num%limits  = limits
            ! loop over individuals
            do i=1,num%NP
                num%pop(i)%w = ran3()
                ! loop over vector values
                do j=1,num%D
                    ! determine interval size
                    if(limits(j,2) > limits(j,1)) then
                    else
                        write( *,* ) 'Bad limits for the constrained optimization!'
                        write( *,* ) 'In: re_init_de_opt: simple_de_opt'
                        write( *,* ) 'Lim(',j,1,'):',limits(j,1),'Lim(',j,2,'):',limits(j,2)
                        stop
                    endif
                    ! store the initial random values within the range in pop
                    num%pop(i)%vec(j) = (limits(j,2)-limits(j,1))*ran3()+limits(j,1)
                end do
            end do
            if( present(init_sols) )then
                call reset_ran_tabu( num%tab )
                call ne_ran_iarr( num%tab, order )  
                ! loop over individuals
                do ir=1,num%NP
                    i = order(ir) ! input individuals randomly ordered to promote neighbourhood diversity 
                    ! loop over vector values
                    do j=1,num%D
                        if( init_sols(i,j) < limits(j,1) .or.&
                            init_sols(i,j) > limits(j,2)) then                        
                            write( *,* ) 'Initial solution is out of bound!'
                            write( *,* ) 'In: re_init_de_opt: simple_de_opt'
                            write( *,* ) 'Val: ', init_sols(i,j),'Lim(',j,1,'):',&
                            limits(j,1),'Lim(',j,2,'):',limits(j,2)
                        endif
                        ! store the init solutions in pop
                        num%pop(i)%vec(j) = init_sols(i,j)
                    end do
                    call check_vec( num, num%pop(i)%vec )
                end do
            endif
        else
            write(*,*) 'simple_de_opt object does not exist!'
            write(*,*) 'In: re_init_de_opt: simple_de_opt'
            stop
        endif
    end subroutine re_init_de_opt
    
    function get_de_popsize( num )result( NP )
        type(de_opt) :: num
        integer :: NP
        NP = num%NP
    end function get_de_popsize
    
    function get_de_vecdim( num )result( D )
        type(de_opt) :: num
        integer :: D
        D = num%D
    end function get_de_vecdim
    
    subroutine print_de_pop( num )
        type(de_opt) :: num
        integer :: j
        do j=1,num%NP
            write(*,*) 'member:', j, 'vec:', num%pop(j)%vec(:)
        end do
    end subroutine print_de_pop
    
    subroutine get_de_pop( num, vecpop )
        type(de_opt)      :: num
        real, intent(out) :: vecpop(num%NP,num%D+1)
        integer           :: i
        ! charge the array
        do i=1,num%NP
            vecpop(i,:num%D) = num%pop(i)%vec(:)
            vecpop(i,num%D+1) = num%pop(i)%F
        end do
    end subroutine get_de_pop

    subroutine get_de_vec( num, i, vec, cost )
        type(de_opt) :: num
        integer, intent(in) :: i
        real, intent(out) :: vec(num%D), cost
        vec = num%pop(i)%vec
        cost = num%pop(i)%cost
    end subroutine get_de_vec
    
    subroutine read_de_pop( num, fnr, irec )
    ! is for reading a de-population from a binary file (assumed to be open)
        type(de_opt)        :: num
        integer, intent(in) :: fnr
        integer, intent(in) :: irec
        real, allocatable   :: vecpop(:,:)
        integer             :: alloc_stat, i
        allocate( vecpop(num%NP,num%D+1), stat=alloc_stat )
        call alloc_err( 'In: read_de_pop module: simple_de_opt.f90', alloc_stat )
        ! read data from binary file (assuming that it is open)
        read(fnr,rec=irec) vecpop
        ! charge the population
        do i=1,num%NP
            num%pop(i)%vec(:) = vecpop(i,:num%D)
            num%pop(i)%F = vecpop(i,num%D+1)
            call check_vec( num, num%pop(i)%vec )
        end do
        deallocate( vecpop )
    end subroutine read_de_pop
    
    subroutine find_best_glob( num )
    ! is for finding the fittest solution globally
        type(de_opt) :: num
        integer :: minpos(1)
        minpos = minloc(num%pop(:)%cost)
        num%best_glob = minpos(1)
        num%best_glob_cost = num%pop(num%best_glob)%cost
    end subroutine find_best_glob
    
    subroutine find_best_loc( num )
    ! is for finding the fittest solutions in the local neighborhood model 
        type(de_opt) :: num
        integer      :: minpos(1), i, j, counter
        integer      :: neigh(2*num%neigh+1)
        real         :: costs(2*num%neigh+1)
        do i=1,num%NP
            counter = 0
            do j=i-num%neigh,i+num%neigh
                counter = counter+1
                neigh(counter) = cyci(num%NP, j)
                costs(counter) = num%pop(neigh(counter))%cost
            end do
            minpos = minloc(costs)
            num%pop(i)%best_loc = neigh(minpos(1))
            num%pop(i)%best_loc_cost = num%pop(neigh(minpos(1)))%cost
        end do
    end subroutine find_best_loc
    
    subroutine de_cont_min( num, fun, GENMAX, cost_error, solution, cost_fittest )
    ! is the constrained _DE_ minimization, _fun_ is the externally defined function, _GENMAX_
    ! is the maximum number of generations, _cost_error_ is the cost function error, 
    ! _solution_ is the output solution (the fittest vec), and _cost_fittest_ the cost of the fittest vec
        interface
            function fun( vec, D ) result( cost )
                integer, intent(in) :: D
                real, intent(in)    :: vec(D)
                real                :: cost
            end function fun 
        end interface
        type(de_opt), intent(inout) :: num
        real, intent(out)           :: solution(num%D)
        integer, intent(in)         :: GENMAX ! maximum number of generations
        real, intent(in)            :: cost_error
        real, intent(out)           :: cost_fittest
        real                        :: costs(2)
        integer                     :: j, i, ir, convergence, order(num%NP)   
        ! Initialization        
        costs = 99999999.
        convergence = 0
        ! calculate costs for the init pop
        do i=1,num%NP
            num%pop(i)%cost = calc_cost( num, fun, num%pop(i) )
        end do
        ! find local and global best vecs
        call find_best_glob( num )
        call find_best_loc( num )
        ! loop over generations
        do j=1,GENMAX
            ! randomize
            call reset_ran_tabu( num%tab )
            call ne_ran_iarr( num%tab, order )
            ! loop over individuals
            do ir=1,num%NP 
                i = order(ir) ! randomized ring search        
                call m_and_x_loc( num, i )
                call m_and_x_glob( num, i )
                call comb_and_check( num, i )
                num%trial%cost = calc_cost( num, fun, num%trial )
                call sel( num, i )
            end do
            costs(1) = costs(2) ! Cost update
            costs(2) = num%best_glob_cost
            if(abs(costs(1)-costs(2)) <= cost_error*0.5) then
                convergence = convergence+1
            else
                convergence = 0
            end if
            if(convergence >= 20) then
                exit
            endif
        end do
        solution = num%pop(num%best_glob)%vec
        cost_fittest = num%best_glob_cost
    end subroutine de_cont_min
    
    function calc_cost( num, fun, individual ) result(cost)
    ! is for calculating cost using an externally defined function
        type(de_opt)          :: num
        real, external        :: fun
        type(ind), intent(in) :: individual
        real :: cost
        cost = fun( individual%vec, num%D )
    end function calc_cost
    
    subroutine sel( num, i )
    ! is for selecting trial solutions for replacement
        type(de_opt)        :: num
        integer, intent(in) :: i
        integer             :: j, ix
        if( num%trial%cost <= num%pop(i)%cost ) then
            num%pop(i)%cost = num%trial%cost
            num%pop(i)%F    = num%trial%F
            num%pop(i)%vec  = num%trial%vec
            num%pop(i)%w    = num%trial%w
            if( num%trial%cost <= num%best_glob_cost ) then
                num%best_glob = i
                num%best_glob_cost = num%trial%cost
            endif
            do j=i-num%neigh,i+num%neigh
                ix = cyci(num%NP, j)
                if( num%trial%cost <= num%pop(ix)%best_loc_cost ) then
                    num%pop(ix)%best_loc = i
                    num%pop(ix)%best_loc_cost = num%trial%cost
                endif
            end do
        end if        
    end subroutine sel
    
    subroutine check_vec( num, vec )
    ! check the vector with respect to the limits
        type(de_opt)        :: num
        real, intent(inout) :: vec(num%D)
        integer             :: j 
        do j=1,num%D
            if( num%cyclic(j) ) then
                ! this is to account for the cyclic behaviour of Euler angles
                do while( vec(j) < num%limits(j,1) ) 
                    vec(j) = num%limits(j,2)+vec(j)
                end do
                do while( vec(j) > num%limits(j,2) )
                    vec(j) = vec(j)-num%limits(j,2)
                end do
            else
                ! generate a point by controlled randomization
                if( vec(j) < num%limits(j,1) ) then
                    ! random point in the lower half of the interval
                    vec(j) = (num%limits(j,2)-num%limits(j,1))*0.5*ran3()+num%limits(j,1)
                else if( vec(j) > num%limits(j,2) ) then
                    ! random point in the upper half of the interval
                    vec(j) = (num%limits(j,2)-num%limits(j,1))*(1.-0.5*ran3())+num%limits(j,1)
                endif
            endif
        end do
    end subroutine check_vec
    
    subroutine m_and_x_loc( num, i )
    ! generates a trial solution vector using a local neighborhood model
        type(de_opt)        :: num 
        integer, intent(in) :: i
        real                :: k, f2
        integer             :: j, a(2), neigh(2*num%neigh+1), counter, excl
        excl = 0
        counter = 0
        do j=i-num%neigh,i+num%neigh
            counter = counter+1
            neigh(counter) = cyci(num%NP, j)
            if( neigh(counter) == num%pop(i)%best_loc ) excl = counter
        end do
        ! generate the non-equal two random numbers, not equal to best_loc    
        a(1) = excl
        do while( a(1) == excl ) 
            a(1) = irnd_uni(2*num%neigh+1)
        end do
        a(2) = excl
        do while( a(2) == a(1) .or. a(2) == excl )
            a(2) = irnd_uni(2*num%neigh+1)
        end do
        ! self-adaption of the amplification factor
        if( ran3() < 0.1 ) then
            num%trial%F   = 0.1+0.9*ran3()
        else
            num%trial%F  = num%pop(i)%F
        endif
        ! this act of linear combination replaces mutation and crossover
        k = ran3()
        f2 = num%trial%F*k
        num%trial_loc%vec = num%pop(i)%vec + k*(num%pop(num%pop(i)%best_loc)%vec-num%pop(i)%vec) +&
        f2*(num%pop(neigh(a(1)))%vec-num%pop(neigh(a(2)))%vec)  
    end subroutine m_and_x_loc
    
    subroutine m_and_x_glob( num, i )
    ! generates a trial solution vector using a global neighborhood model
        type(de_opt)        :: num 
        integer, intent(in) :: i
        integer             :: a(4)
        real                :: k, f2
        ! generate the non-equal four random numbers, not equal to the global best
        call reset_ran_tabu( num%tab )
        call insert_ran_tabu( num%tab, num%best_glob ) 
        call ne_ran_iarr( num%tab, a )         
        ! this act of 'randomized' linear combination replaces mutation and crossover
        k = ran3()
        f2 = num%trial%F*k
        num%trial_glob%vec = num%pop(i)%vec + k*(num%pop(num%best_glob)%vec-num%pop(i)%vec) +&
        f2*(num%pop(a(1))%vec+num%pop(a(2))%vec-num%pop(a(3))%vec-num%pop(a(4))%vec)
        ! now m&x the weight, note the change of F (no crossover performed)
        num%trial%w = num%pop(i)%w + num%trial%F*(num%pop(num%best_glob)%w-num%pop(i)%w) +&
        num%trial%F*(num%pop(a(1))%w+num%pop(a(2))%w-num%pop(a(3))%w-num%pop(a(4))%w)
        if( num%trial%w > 0.95) num%trial%w = 0.95
        if( num%trial%w < 0.05) num%trial%w = 0.05
    end subroutine m_and_x_glob
     
    subroutine comb_and_check( num, i )
        type(de_opt)        :: num
        integer, intent(in) :: i
        num%trial%w   = num%pop(i)%w
        num%trial%vec = num%trial%w*num%trial_glob%vec+(1.-num%trial%w)*num%trial_loc%vec
        call check_vec( num, num%trial%vec )
    end subroutine comb_and_check 
        
    subroutine kill_de_opt( num )
    ! is a destructor
        type(de_opt) :: num
        integer      :: i
        if( num%exists )then
            call kill_ran_tabu( num%tab )
            deallocate( num%trial%vec )
            deallocate( num%trial_loc%vec )
            deallocate( num%trial_glob%vec )
            do i=1,num%NP
                deallocate( num%pop(i)%vec )    
            end do    
            deallocate( num%pop )
            num%exists = .false.
       endif
    end subroutine kill_de_opt
    
end module simple_de_opt