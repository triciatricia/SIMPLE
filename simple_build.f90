!==Class simple_build
!
! simple_build is the builder singleton class for the methods in _SIMPLE_. Access is global in the
! using unit. The code is distributed with the hope that it will be useful, but _WITHOUT_ _ANY_ _WARRANTY_.
! Redistribution or modification is regulated by the GNU General Public License. 
! *Author:* Hans Elmlund, 2009-06-11.
! 
!==Changes are documented below
!
!* deugged and incorporated in the _SIMPLE_ library, HE 2009-06-25
!* reshaped according to the new simple_params class that will deal with all global parameters, HE 2011-08-18
!
module simple_build
use simple_params
use simple_eulers
use simple_comlin
use simple_heapsort
use simple_aligndata
use simple_volspi
use simple_jiffys
use simple_math
use simple_rnd
use simple_ffts
use simple_fplane
implicit none
save

private :: instance_count, state3d, rvol_clone
public

type state3d
    complex, allocatable       :: fvol(:,:,:), fvol_new(:,:,:) ! 3D transform data 
    real, allocatable          :: kernel(:,:,:)                ! kernel data
    real, allocatable, private :: rvol(:,:,:)                  ! real volume data
    type(volspi)               :: vspi                         ! spider volume functionality object
end type

type build
! builds _eulers_ objects (for generation of alignment spaces, symmetry operations and reference orientations),
! _fplanes_ and _fvol_ arrays (for 2D and 3D Fourier transform handling), _comlin_ objects (for generation, 
! storage and use of common lines), _heapsort_ objects (for sorting solutions generated by exhaustive search), 
! an _aligndata_ object (for storage and access of aligndata info), _rescorr_ and _arescorr_ arrays (for spectral analysis).
    type(eulers)               :: e, e_ref
    type(heapsort)             :: hso
    type(aligndata)            :: a
    type(state3d), allocatable :: s3d(:)
    type(fp), allocatable      :: f(:), frefs(:)
    real, pointer              :: reftrs(:,:)
    integer, pointer           :: statearr(:)
    integer, pointer           :: bootarr(:)
    real,allocatable           :: rescorr(:), arescorr(:)
    logical                    :: exists=.false.
end type build

integer :: instance_count = 0
real, allocatable :: rvol_clone(:,:,:)

contains
  
    function new_build(md) result( num )
    ! constructs the builder singleton for the alignment methods in _SIMPLE_.
    ! modes 10-19: _reference_ _free_ _comlin_ _alignment_ & _heterogeneity_ _analysis_, 
    ! modes 20-39: _refinement_ _methods_
    ! modes 30-39: _volume_ _reconstruction_ _methods_
    ! For detailed specification of modes, see the evol_align main program
        integer, intent(in), optional :: md
        type(build)   :: num
        real          :: e1, e2, e3, x, y
        integer       :: i, s, alloc_stat
        ! increase instance counter 
        instance_count = instance_count+1
        if( instance_count > 1 ) then
            write(*,'(A)') '>>> ERROR, singleton class simple_build is already instantiated!'
            stop
        endif
        if( present(md) )then
            call make_params( md )
        else
            call make_params
        endif
        write(*,'(A)') '>>> BUILDING SIMPLE OBJECTS'
        ! create object for storing aligndata
        num%a = new_aligndata(fromp, top) 
        if(oritab /= '' )then
            do i=fromp,top
                e1 = oris(i,1)
                e2 = oris(i,2)
                e3 = oris(i,3)
                x  = oris(i,4)
                y  = oris(i,5)
                s  = oris(i,6)
                call set_aligndata(num%a, i, e1=e1, e2=e2, e3=e3, x=x, y=y, state=s)
             end do
        endif  
        ! calculate even Eulers
        num%e = new_eulers(nspace)
        call spiral_eulers(num%e, pgrp)
        if( mode < 20 .and. mode >= 10 )then ! Reference-free 3D analysis
            ! build e_ref is for the orientation matrices
            num%e_ref = new_eulers(nptcls) 
            if((mode == 11 .or. mode == 12) .or. mode == 14)then ! State assignment etc. on input orientations
                ! so previously established orientations will have to be used
                do i=1,nptcls
                    call set_euler( num%e_ref, i, oris(i,1), oris(i,2), oris(i,3) )
                end do
            endif
            ! Allocate arrays
            allocate( num%reftrs(nptcls,2), num%statearr(nptcls), num%bootarr(1), stat=alloc_stat )
            call alloc_err( 'In: new_build, module: simple_build.f90, allocation 1', alloc_stat )
            num%reftrs  = 0.
            num%statearr = 1
        endif  
        write(*,'(A)') '>>> ALLOCATING & READING VOLUMES/IMAGES/TRANSFORMS'  
        ! allocate
        allocate( num%f(nfpl), num%rescorr(fromk:tok), num%arescorr(fromk:tok),&
        num%frefs(-navgs:nfrefs), stat=alloc_stat  )
        num%rescorr = 0.
        num%arescorr = 0.
        call alloc_err( 'In: new_build, module: simple_build.f90, allocation 4', alloc_stat )
        do i=1,nfpl
            allocate( num%f(i)%arr(-xdim:xdim,-xdim:xdim), stat=alloc_stat )
            call alloc_err( 'In: new_build, module: simple_build.f90, allocation 5', alloc_stat )
        end do
        do i=-navgs,nfrefs
            allocate( num%frefs(i)%arr(-xdim:xdim,-xdim:xdim), stat=alloc_stat )
            call alloc_err( 'In: new_build, module: simple_build.f90, allocation 6', alloc_stat )
        end do
        if( mode < 20 .and. mode >= 10 )then
            ! Build common lines object
            call make_comlin(num%f)
            ! read Fourier planes
            do i=1,nptcls
                call read_fplane( num%f(i)%arr, fstk, i )
            end do 
        endif
        allocate(num%s3d(nstates), rvol_clone(box,box,box), stat=alloc_stat)
        call alloc_err('In: new_build, module: simple_build.f90, allocation 7', alloc_stat)
        ! prepare for 3d ffts
        call prep_3dfft( box )
        do i=1,nstates
            allocate( num%s3d(i)%fvol(-xdim:xdim,-xdim:xdim,-xdim:xdim),&
                      num%s3d(i)%fvol_new(-xdim:xdim,-xdim:xdim,-xdim:xdim),&
                      num%s3d(i)%rvol(box,box,box),&
                      num%s3d(i)%kernel(-xdim:xdim,-xdim:xdim,-xdim:xdim), stat=alloc_stat )
            call alloc_err( 'In: new_build, module: simple_build.f90, allocation 8', alloc_stat )
            num%s3d(i)%vspi = new_volspi(num%s3d(i)%rvol, box)
            if( vols(i) /= '' .and. mode /= 30 )then
                ! read reference volumes
                call read_volspi( num%s3d(i)%vspi, vols(i) )
                ! normalize reference volumes
                call norm_volspi( num%s3d(i)%vspi )
                ! mask with a soft mask
                if( msk > 1. ) call mask_volspi( num%s3d(i)%vspi, msk )
                ! generate Fourier volume
                call fft_vspi( num, i )
            endif
        end do
        ! make heapsort object
        if( mode <= 2 )then
            num%hso = new_heapsort(nptcls)
        else
            num%hso = new_heapsort(ninpl*nspace)
        endif
        num%exists = .true.
        write(*,'(A)') '>>> DONE BUILDING'
    end function new_build
    
    subroutine kill_build( num )
        type(build) :: num
        integer :: s, i
        call kill_eulers(num%e)
        call kill_eulers(num%e_ref)
        call kill_heapsort(num%hso)
        call kill_aligndata(num%a)
        if( allocated(num%s3d) )then
            do s=1,nstates
                call kill_volspi( num%s3d(s)%vspi )
                deallocate( num%s3d(s)%fvol, num%s3d(s)%fvol_new, num%s3d(s)%rvol, num%s3d(s)%kernel )
            end do
        endif
        if( allocated(num%f) )then
            do i=1,nptcls
                deallocate(num%f(i)%arr)
            end do
            deallocate(num%f)
        endif
        if( allocated(num%frefs) )then
            do i=-navgs,nfrefs
                deallocate(num%frefs(i)%arr)
            end do
            deallocate(num%frefs)
        endif
        if( associated(num%reftrs) )   deallocate(num%reftrs)
        if( associated(num%statearr) ) deallocate(num%statearr)
        if( associated(num%bootarr) )  deallocate(num%bootarr)
        if( allocated(num%rescorr) )   deallocate(num%rescorr)
        if( allocated(num%arescorr) )  deallocate(num%arescorr)
        call kill_params 
        instance_count = 0
        num%exists = .false.
    end subroutine kill_build
    
    ! Fourier volume methods
    
    subroutine lp_fvol( num, s, lplim )
        type(build)         :: num
        integer, intent(in) :: s
        real, intent(in)    :: lplim
        integer             :: h, k, l, target_to
        real                :: fwght, w(-xdim:xdim)
        ! determine the low-pass Fourier index
        target_to = nint(2.*(dstep/lplim))
        if( target_to > tofny ) then
            target_to = tofny
        else if( target_to < 3 ) then
            target_to = 3
        endif
        ! Make a one dimensional window
        w = 0.
        call gauwin(target_to, 0.5, w(-target_to:target_to))
        do h=-xdim,xdim
            do k=-xdim,xdim
                do l=-xdim,xdim
                    fwght = w(h)*w(k)*w(l)
                    num%s3d(s)%fvol(h,k,l) = cmplx(fwght*real(num%s3d(s)%fvol(h,k,l)),&
                    fwght*aimag(num%s3d(s)%fvol(h,k,l)))
                end do
            end do
        end do
    end subroutine lp_fvol
    
    subroutine shift_fvol( num, s, x, y, z )
    ! is for origin shifting the Fourier plane
        type(build)         :: num
        integer, intent(in) :: s
        real, intent(in)    :: x, y, z
        integer             :: h, k, l
        real                :: arg
        if( x /= 0. .and. (y /= 0. .and. z /= 0.) )then
            do h=-xdim,xdim
                do k=-xdim,xdim
                    do l=-xdim,xdim
                        arg = (twopi/real(box))*(x*real(h)+y*real(k)+z*real(l))
                        num%s3d(s)%fvol(h,k,l) = num%s3d(s)%fvol(h,k,l)*cmplx(cos(arg),sin(arg))
                    end do
                end do
            end do
        endif
    end subroutine shift_fvol

    subroutine fft_rev_fvol( num, s )
    ! debug ok
        type(build)         :: num
        integer, intent(in) :: s
        call simple_3dfft_rev( num%s3d(s)%fvol, xdim, num%s3d(s)%rvol, box )
        call set_volspi_ptr( num%s3d(s)%vspi, num%s3d(s)%rvol )
        call shift_volspi( num%s3d(s)%vspi ) 
    end subroutine fft_rev_fvol

    subroutine fft_rev_fvol_new( num, s )
    ! debug ok
        type(build)         :: num
        integer, intent(in) :: s
        call simple_3dfft_rev( num%s3d(s)%fvol_new, xdim, num%s3d(s)%rvol, box )
        call set_volspi_ptr( num%s3d(s)%vspi, num%s3d(s)%rvol )
        call shift_volspi( num%s3d(s)%vspi ) 
    end subroutine fft_rev_fvol_new

    ! Volume methods
    
    subroutine fft_vspi( num, s )
    ! debug ok
        type(build)         :: num
        integer, intent(in) :: s
        call shift_volspi( num%s3d(s)%vspi )       
        call simple_3dfft( num%s3d(s)%rvol, box, num%s3d(s)%fvol, xdim )
        call shift_volspi( num%s3d(s)%vspi )
    end subroutine fft_vspi

    subroutine center_vspi( num, s )
        type(build) :: num
        integer, intent(in) :: s
        real :: xsh, ysh, zsh
        ! binarize volume
        call binarize_vspi( num, s )
        ! determine center of mass
        call masscen_volspi( num%s3d(s)%vspi, xsh, ysh, zsh )
        ! read back the original (unfiltered) volume
        call read_volspi(num%s3d(s)%vspi, vols(s) )
        ! normalize volume
        call norm_volspi( num%s3d(s)%vspi )
        ! Fouirer transform
        call fft_vspi( num, s )
        ! shift according to center of mass
        call shift_fvol( num, s, xsh, ysh, zsh )
        ! reverse transform
        call fft_rev_fvol( num, s )
    end subroutine center_vspi

    subroutine binarize_vspi( num, s )
        type(build) :: num
        integer, intent(in) :: s
        integer :: npix
        ! low-pass filter volume
        call lp_fvol( num, s, lp )
        ! reverse FT
        call fft_rev_fvol( num, s )
!        call write_volspi( num%s3d(1)%vspi, 'filtered.spi' )
        ! binarize volume
        npix = find_pixvol(smpd,mw)
        call bin_volspi(num%s3d(s)%vspi, npix)
    end subroutine binarize_vspi
    
    subroutine automask_vspi( num, s )
        type(build) :: num
        integer, intent(in) :: s
        ! make a copy of the volume
        rvol_clone = num%s3d(s)%rvol
        ! binarize
        call binarize_vspi( num, s )
!        call write_volspi( num%s3d(1)%vspi, 'binvol.spi' )
        ! forward FFT
        call fft_vspi( num, s )
        ! low-pass filter the Fourier volumes
        call lp_fvol( num, s, max(20.,lp/2.) )
        ! reverse FFT
        call fft_rev_fvol( num, s )
        ! write mask to file
        call write_volspi( num%s3d(s)%vspi, masks(s) )
        ! multiply with the clone
        num%s3d(s)%rvol = num%s3d(s)%rvol*rvol_clone
        ! normalize
        call norm_volspi( num%s3d(s)%vspi )
        ! write volume to file
        call write_volspi( num%s3d(s)%vspi, vols_msk(s) )
        ! regenerate the Fourier reference
        call fft_vspi( num, s )
    end subroutine automask_vspi
    
end module simple_build